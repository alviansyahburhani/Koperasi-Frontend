import { defineStore } from "pinia";
import { j as createError, f as useRuntimeConfig, n as navigateTo } from "../server.mjs";
import "vue";
class ApiService {
  baseURL;
  timeout;
  debugMode;
  initialized = false;
  constructor() {
    this.baseURL = "";
    this.timeout = 3e4;
    this.debugMode = false;
  }
  /**
   * Initialize config
   */
  initConfig() {
    if (!this.initialized) {
      const config = useRuntimeConfig();
      this.baseURL = config.public.apiBase;
      this.timeout = config.public.apiTimeout;
      this.debugMode = config.public.debugMode;
      this.initialized = true;
      if (this.debugMode) {
        console.log("[ApiService] Initialized:", { baseURL: this.baseURL });
      }
    }
  }
  /**
   * Get headers with auth token
   */
  getHeaders() {
    const headers = {
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    return headers;
  }
  /**
   * Handle API Error
   * ✅ FIX: useErrorHandler hunknowna bisa dipanggil di Nuxt context
   */
  handleError(error) {
    const statusCode = error.statusCode || error.response?.status || 500;
    const message = error.message || error.response?.data?.message || "Terjadi kesalahan";
    if (this.debugMode) {
      console.error("[ApiService] Error:", {
        statusCode,
        message,
        error
      });
    }
    throw createError({
      statusCode,
      message,
      data: error.response?.data
    });
  }
  /**
   * Make HTTP Request
   */
  async request(method, endpoint, data) {
    this.initConfig();
    const url = `${this.baseURL}${endpoint}`;
    if (this.debugMode) {
      console.log(`[ApiService] ${method} ${url}`, data);
    }
    try {
      const response = await $fetch(url, {
        method,
        headers: this.getHeaders(),
        body: data,
        timeout: this.timeout,
        retry: method === "GET" ? 2 : 0,
        retryDelay: 1e3
      });
      if (this.debugMode) {
        console.log(`[ApiService] Response ${method} ${url}:`, response);
      }
      return response;
    } catch (error) {
      if (this.debugMode) {
        console.error(`[ApiService] Error ${method} ${url}:`, error);
      }
      this.handleError(error);
    }
  }
  /**
   * GET request
   */
  async get(endpoint) {
    return this.request("GET", endpoint);
  }
  /**
   * POST request
   */
  async post(endpoint, data) {
    return this.request("POST", endpoint, data);
  }
  /**
   * PUT request
   */
  async put(endpoint, data) {
    return this.request("PUT", endpoint, data);
  }
  /**
   * PATCH request
   */
  async patch(endpoint, data) {
    return this.request("PATCH", endpoint, data);
  }
  /**
   * DELETE request
   */
  async delete(endpoint) {
    return this.request("DELETE", endpoint);
  }
}
const apiService = new ApiService();
class AuthService {
  /**
   * ✅ Detect if Super Admin based on URL
   * Super Admin = localhost tanpa subdomain
   * Tenant = subdomain.localhost
   */
  isSuperAdminContext() {
    return false;
  }
  /**
   * Login - Auto detect super admin vs tenant based on URL
   */
  async login(credentials) {
    const config = useRuntimeConfig();
    const isSuperAdmin = this.isSuperAdminContext();
    if (config.public.debugMode) {
      console.log("[AuthService] Login context:", {
        email: credentials.email,
        hostname: "SSR",
        isSuperAdmin
      });
    }
    const endpoint = isSuperAdmin ? "/api/admin/auth/login" : "/api/auth/login";
    if (config.public.debugMode) {
      console.log("[AuthService] Using endpoint:", endpoint);
    }
    return apiService.post(endpoint, {
      email: credentials.email,
      password: credentials.password
    });
  }
  /**
   * Get User Profile from Backend
   */
  async getProfile() {
    const isSuperAdmin = this.isSuperAdminContext();
    const endpoint = isSuperAdmin ? "/api/admin/auth/profile" : "/api/auth/profile";
    const response = await apiService.get(endpoint);
    return {
      id: response.id || response.sub,
      email: response.email,
      role: response.role,
      name: response.name,
      tenantId: response.tenantId
    };
  }
  /**
   * Refresh Token
   */
  async refreshToken() {
    const isSuperAdmin = this.isSuperAdminContext();
    const endpoint = isSuperAdmin ? "/api/admin/auth/refresh" : "/api/auth/refresh";
    return apiService.post(endpoint, {});
  }
  /**
   * Logout
   */
  async logout() {
  }
  /**
   * Decode JWT Token
   */
  decodeToken(token) {
    try {
      const parts = token.split(".");
      if (parts.length !== 3) {
        console.error("[AuthService] Invalid token format");
        return null;
      }
      const base64Url = parts[1];
      if (!base64Url) {
        console.error("[AuthService] Token payload is missing");
        return null;
      }
      const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
      const jsonPayload = decodeURIComponent(
        atob(base64).split("").map((c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)).join("")
      );
      return JSON.parse(jsonPayload);
    } catch (error) {
      console.error("[AuthService] Failed to decode token:", error);
      return null;
    }
  }
  /**
   * Check if token is expired
   */
  isTokenExpired(token) {
    const payload = this.decodeToken(token);
    if (!payload || !payload.exp) return true;
    const now = Math.floor(Date.now() / 1e3);
    return payload.exp < now;
  }
}
const authService = new AuthService();
const useAuthStore = defineStore("auth", {
  state: () => ({
    user: null,
    token: null,
    refreshToken: null,
    isAuthenticated: false,
    loading: false
  }),
  getters: {
    /**
     * User role (raw dari backend)
     */
    userRole: (state) => state.user?.role || null,
    /**
     * Super Admin check
     */
    isSuperadmin: (state) => {
      const role = state.user?.role?.toUpperCase();
      return role === "SUPERADMIN";
    },
    /**
     * ✅ Pengurus check (admin koperasi)
     */
    isPengurus: (state) => {
      const role = state.user?.role;
      return role === "Pengurus";
    },
    /**
     * ✅ Pengawas check (supervisor koperasi)
     */
    isPengawas: (state) => {
      const role = state.user?.role;
      return role === "Pengawas";
    },
    /**
     * ✅ Anggota check (member koperasi)
     */
    isAnggota: (state) => {
      const role = state.user?.role;
      return role === "Anggota";
    },
    /**
     * ✅ isAdmin = Pengurus OR Pengawas
     * (kedua role ini bisa akses admin dashboard)
     */
    isAdmin: (state) => {
      const role = state.user?.role;
      return role === "Pengurus" || role === "Pengawas";
    }
  },
  actions: {
    /**
     * Login
     */
    async login(credentials) {
      this.loading = true;
      const config = useRuntimeConfig();
      try {
        if (config.public.debugMode) {
          console.log("[AuthStore] Login start:", credentials.email);
        }
        const response = await authService.login(credentials);
        if (config.public.debugMode) {
          console.log("[AuthStore] Login response received");
        }
        this.token = response.accessToken;
        this.refreshToken = response.refreshToken;
        this.isAuthenticated = true;
        if (false) ;
        const payload = authService.decodeToken(response.accessToken);
        if (payload) {
          const isSuperAdminContext = authService.isSuperAdminContext();
          if (config.public.debugMode) {
            console.log("[AuthStore] Is Super Admin context:", isSuperAdminContext);
            console.log("[AuthStore] JWT payload:", payload);
          }
          this.user = {
            id: payload.sub,
            email: payload.email,
            // ✅ FIX: Set 'SUPERADMIN' if login from localhost without subdomain
            role: isSuperAdminContext ? "SUPERADMIN" : payload.role || "ANGGOTA",
            tenantId: payload.tenantId,
            name: payload.email.split("@")[0]
            // Fallback name
          };
          if (false) ;
          if (config.public.debugMode) {
            console.log("[AuthStore] User profile set from JWT:", this.user);
          }
        }
        if (response.warning) {
          console.warn("[AuthStore] Login warning:", response.warning);
        }
        return {
          success: true,
          message: "Login berhasil!"
        };
      } catch (error) {
        console.error("[AuthStore] Login error:", error);
        this.user = null;
        this.token = null;
        this.refreshToken = null;
        this.isAuthenticated = false;
        let message = "Login gagal. Silakan coba lagi.";
        if (error.statusCode === 401) {
          message = "Email atau password salah.";
        } else if (error.statusCode === 404) {
          message = "Server tidak dapat dihubungi. Pastikan backend berjalan.";
        } else if (error.statusCode === 500) {
          message = "Server sedang bermasalah. Silakan coba lagi nanti.";
        } else if (error.message) {
          message = Array.isArray(error.message) ? error.message[0] : error.message;
        }
        return {
          success: false,
          message
        };
      } finally {
        this.loading = false;
      }
    },
    /**
     * Fetch user profile (optional - jika mau refresh dari backend)
     */
    async fetchProfile() {
      try {
        const profile = await authService.getProfile();
        if (useRuntimeConfig().public.debugMode) {
          console.log("[AuthStore] Profile fetched from API:", profile);
        }
        this.user = profile;
        if (false) ;
      } catch (error) {
        console.error("[AuthStore] Fetch profile error:", error);
        throw error;
      }
    },
    /**
     * Logout
     */
    async logout() {
      try {
        await authService.logout();
      } catch (error) {
        console.error("[AuthStore] Logout error:", error);
      } finally {
        this.user = null;
        this.token = null;
        this.refreshToken = null;
        this.isAuthenticated = false;
        navigateTo("/auth/login");
      }
    },
    /**
     * Initialize auth from storage (called on app start)
     */
    async initAuth() {
      return;
    }
  }
});
export {
  useAuthStore as u
};
//# sourceMappingURL=auth-Di8Nwi7s.js.map
